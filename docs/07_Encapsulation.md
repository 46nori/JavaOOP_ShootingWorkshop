# Step 7: カプセル化 (Encapsulation)

オブジェクト指向の三大要素の最後は **カプセル化 (Encapsulation)** です。
これは「データ（フィールド）を隠して、勝手に触らせないようにする」という考え方です。

一見、「自由に書き換えられた方が便利じゃない？」と思うかもしれません。しかし、プログラムが大きくなればなるほど、**「どこからでも書き換えられる」ことは「いつの間にか壊される」リスク** に変わります。

## 😱 カプセル化しないとどうなる？

もし `hp`（体力）というフィールドが `public` だったら、誰でも自由に書き換えられます。

```java
// 誰かが間違ってこんなコードを書いたら...
enemy.hp = -9999; // いきなり死んだ！
enemy.hp = 1000000; // 無敵になった！
```

これでは、ゲームのルールが簡単に壊れてしまいますし、バグが起きたときに「誰がこの変な値を入れたんだ！？」と犯人探しをするのが大変になります。

## 🛡️ カプセル化のメリット

カプセル化を行うと、次のようなメリットがあります。

### 1. 不正な値を防げる（データの保護）

フィールドを `private` にして直接触れないようにし、代わりに `setHp` メソッドを用意します。
メソッドを経由させることで、**「チェック機能」** を付けることができます。

```java
// フィールドは隠す
private int hp;

// 値を入れるためのメソッド (Setter)
public void setHp(int hp) {
    // チェック！ 0より小さい値は入れさせない
    if (hp < 0) {
        this.hp = 0;
    } else {
        this.hp = hp;
    }
}
```

これで、誰がどんな値を入れようとしても、`hp` がマイナスになることは絶対にありません。クラス自身が自分の身を守ることができるのです。

### 2. 内部の変更に強くなる（保守性）

例えば、今は `x`, `y` という2つの変数で座標を管理していますが、将来 `Point` クラスを使って管理したくなったとします。

もし `public` で公開していたら、`enemy.x` を使っているすべてのファイルを修正しなければなりません。
しかし、`getX()` というメソッド経由にしていれば、**使う側のコードは一切変更せずに**、中身だけを修正できます。

```java
// 内部の実装が変わっても...
private Point point; 

// 使う側には影響を与えない！
public double getX() {
    return point.x; 
}
```

## 🔑 アクセス修飾子 (Access Modifier)

Javaでは、クラスや変数、メソッドに「誰がアクセスしていいか」を指定するキーワードをつけることができます。これを **アクセス修飾子** と呼びます。

| 修飾子 | アクセスできる範囲 | イメージ | 使いどころ |
| :--- | :--- | :--- | :--- |
| **`public`** | **どこからでも** | 公園 🏞️ | 誰でも使えるメソッド、定数など |
| **`protected`** | 自分 ＋ **子クラス** ＋ 同じパッケージ | 家の庭 🏡 | 継承した子クラスには使わせたい時 |
| (なし) | 自分 ＋ 同じパッケージ | マンションの共用部 🏢 | パッケージ内だけで共有したい時 |
| **`private`** | **自分のクラス内だけ** | 自分の部屋 🔒 | **フィールド（データ）は基本これ！** |

カプセル化の基本は、**「フィールドは `private`、メソッドは `public`」** です。

## 実装のルール：GetterとSetter

Javaでは、カプセル化のために以下のルールで書くのが一般的です。

1. **フィールドはすべて `private` にする**。
2. **必要な場合のみ**、読み取り用の `get変数名()` と、書き込み用の `set変数名()` を作る。

```java
public class Enemy {
    private double x; // privateにする

    // Getter (読み取り用)
    public double getX() {
        return x;
    }

    // Setter (書き込み用)
    public void setX(double x) {
        this.x = x;
    }
}
```

> **☕ コラム：this ってなに？**
> `this.x = x;` というコードが出てきました。
> - `this.x`: 「このクラス（自分自身）のフィールドにある `x`」
> - `x`: 「メソッドの引数として渡されてきた `x`」
>
> 名前が同じだと、コンピュータはどっちの `x` か分からなくなってしまいます。
> そこで、**「自分の持っているフィールド」を指すときに `this.` をつけます**。
> 「私の `x` に、引数の `x` を代入する」という意味になります。

> **💡 ヒント**:
> EclipseなどのIDEには、フィールドを作った後に「右クリック > Source > Generate Getters and Setters...」を選ぶだけで、これらのメソッドを自動生成してくれる機能があります。

## 実行方法

Eclipse上で `src/step07_encapsulation/GameMain.java` を右クリックし、**[Run As]** > **[Java Application]** を選択します。
見た目は変わりませんが、内部の設計はより堅牢（頑丈）になっています。

次は [Step 8: リファクタリング (Refactoring)](08_Refactoring.md) です。
