# 応用編: 物理演算シミュレーション (Advanced Challenge)

これまでのステップで学んだオブジェクト指向の知識を活かして、より高度なプログラムに挑戦してみましょう。
今回は、敵キャラクター同士がぶつかって跳ね返る「物理シミュレーション」を作成します。

## 🎯 目標と要件

以下の3つの要件を満たすプログラムを作成します。

### 1. リファクタリングと機能拡張

- Step 8で学んだ「定数」や「カプセル化」を適用する。
- 敵のサイズ（半径）をランダムに変更できるようにする。
- 質量（重さ）の概念を取り入れる（大きい敵ほど重く、ぶつかった時に相手を吹き飛ばす）。

### 2. アルゴリズム変更1：壁での反射

- 画面の端に行ったら、反対側から出てくるのではなく、**壁に当たって跳ね返る** ようにする。
- 入射角と反射角が等しくなるように速度を変化させる。

### 3. アルゴリズム変更2：敵同士の衝突と反発

- 敵同士がぶつかったら、物理法則（作用・反作用）に従って反発するようにする。
- 衝突判定は、中心座標だけでなく**半径**を考慮して行う。
- 衝突後の速度は、お互いの **質量** と **衝突角度** から計算する。

---

## 📐 アルゴリズム解説

### 1. 壁での反射

壁に当たるということは、座標が画面の端を超えたということです。
反射させるには、**「壁に垂直な方向の速度を反転させる」** だけでOKです。

- **左右の壁**: X方向の速度 (`vx`) を `vx = -vx` にする。
- **上下の壁**: Y方向の速度 (`vy`) を `vy = -vy` にする。

### 2. 敵同士の衝突判定

2つの円が衝突しているかどうかは、**「中心間の距離」** と **「半径の和」** を比べることで分かります。

- 距離 < (半径A + 半径B) ならば、衝突している！

距離 $d$ は、三平方の定理で求められます。
$$ d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2} $$

### 3. 衝突後の速度計算（物理演算）

ここが一番の難所です。2つの物体が斜めに衝突した場合、速度はどのように変化するでしょうか？
これを計算するには、速度を **「衝突面に対して垂直な成分（法線成分）」** と **「平行な成分（接線成分）」** に分解して考えます。

このプログラムで実装されているのは、**「2次元の完全弾性衝突」** のシミュレーションです。
一見複雑に見えますが、**「斜めの衝突を、正面衝突（法線方向）と、すれ違い（接線方向）に分解して考える」**  というのが最大のポイントです。

#### Step 1. 衝突軸（法線ベクトル）を求める

まず、2つの円の中心を結ぶ線（衝突軸）の向きを求めます。これを **法線ベクトル** $\vec{n}$ と呼びます。

$$ \vec{n} = \frac{\vec{P_2} - \vec{P_1}}{|\vec{P_2} - \vec{P_1}|} = (n_x, n_y) $$

これに垂直な方向（衝突面）を **接線ベクトル** $\vec{t}$ と呼びます。
$$ \vec{t} = (-n_y, n_x) $$

#### Step 2. 速度ベクトルの分解

それぞれの速度を、「衝突軸方向の成分（$v_n$）」と「それに垂直な成分（$v_t$）」に分解します。これはベクトルの **内積** を使って計算できます。

$$ v_{1n} = \vec{v_1} \cdot \vec{n} = v_{1x}n_x + v_{1y}n_y $$
$$ v_{1t} = \vec{v_1} \cdot \vec{t} = v_{1x}t_x + v_{1y}t_y $$

同様に敵Bの $v_{2n}, v_{2t}$ も求めます。

#### Step 3. 1次元の衝突計算（ここが核心！）

分解したおかげで、**法線方向（$n$）成分だけを見れば、単純な正面衝突の問題** として扱えます。接線方向（$t$）成分は、摩擦がないと仮定すれば衝突によって変化しません。

以下の2つの式（運動量保存則と反発係数の式）を連立方程式として解きます。

1. **運動量保存則**:
   $$ m_1 v_{1n} + m_2 v_{2n} = m_1 v'_{1n} + m_2 v'_{2n} $$

2. **反発係数の式** (完全弾性衝突なので $e=1$):
   $$ v'_{2n} - v'_{1n} = -1 \cdot (v_{2n} - v_{1n}) $$

これらを $v'_{1n}, v'_{2n}$ について解くと、衝突後の速度を求める以下の公式が導かれます。

$$ v'_{1n} = \frac{(m_1 - m_2)v_{1n} + 2m_2v_{2n}}{m_1 + m_2} $$

$$ v'_{2n} = \frac{(m_2 - m_1)v_{2n} + 2m_1v_{1n}}{m_1 + m_2} $$

この式により、重い物体（$m$が大きい）と軽い物体がぶつかったとき、軽いほうが大きく弾き飛ばされる挙動が再現できます。

#### Step 4. 速度ベクトルの合成（復元）

計算した新しい法線成分（$v'_{n}$）と、変化していない接線成分（$v_{t}$）を合成して、元のX, Y座標系の速度に戻します。

$$ \vec{v'_1} = v'_{1n}\vec{n} + v_{1t}\vec{t} $$

これを成分で書くと：
$$ v'_{1x} = v'_{1n}n_x + v_{1t}t_x $$
$$ v'_{1y} = v'_{1n}n_y + v_{1t}t_y $$

プログラムでは `Enemy.java` の `collideWith` メソッドにこの計算式が実装されています。
少し難しい数学ですが、コードを読んで「物理法則をプログラムでどう表現するか」を感じ取ってください。

## 💻 実装のポイント

### ベクトルによる管理

これまでは「角度(`angle`)」と「速さ(`speed`)」で動きを管理していましたが、物理演算を行う場合は **「X方向の速度(`vx`)」と「Y方向の速度(`vy`)」**（ベクトル成分）で管理する方が計算が簡単になります。

### 二重ループによる総当たり判定

`GameMain.java` では、全ての敵同士の組み合わせをチェックするために、二重ループを使っています。

```java
for (int i = 0; i < enemies.length; i++) {
    for (int j = i + 1; j < enemies.length; j++) {
        // 自分(i)と、自分より後ろにいる敵(j)との衝突を判定
        enemies[i].collideWith(enemies[j]);
    }
}
```

`j` を `i + 1` から始めることで、「AとB」「BとA」のような重複チェックを防いでいます。

### ダブルバッファリング（ちらつき防止）

アニメーションを行う際、画面（ウィンドウ）に対して直接「消して、描いて」を繰り返すと、描画の途中経過が見えてしまい、画面がチカチカと点滅して見えることがあります（フリッカー現象）。
これを防ぐためのテクニックが **ダブルバッファリング** です。

1. **裏画面（オフスクリーン）を用意する**: メモリ上に、画面と同じサイズの空の画像を作ります。
2. **裏画面に描く**: キャラクターや背景など、すべての描画をこの裏画面に対して行います。
3. **表画面にコピーする**: 描き終わった裏画面を、一瞬で表のウィンドウにコピー（転送）します。

こうすることで、ユーザーには「完成した絵」だけがパラパラ漫画のように切り替わって見えるため、ちらつきのない滑らかなアニメーションになります。

```java
// 1. 裏画面の準備 (初回のみ)
if (offScreenImage == null) {
    offScreenImage = createImage(getWidth(), getHeight());
    offScreenGraphics = offScreenImage.getGraphics();
}

// 2. 裏画面に描画 (背景クリア -> キャラ描画)
offScreenGraphics.setColor(Color.BLACK);
offScreenGraphics.fillRect(0, 0, getWidth(), getHeight());
// ... (敵の描画など) ...

// 3. 表画面に転送
g.drawImage(offScreenImage, 0, 0, this);
```

## 実行方法

Eclipse上で `src/advanced_challenge/GameMain.java` を右クリックし、**[Run As]** > **[Java Application]** を選択します。
大小様々なボールが画面内を飛び回り、ぶつかり合って弾ける様子が観察できるはずです。
