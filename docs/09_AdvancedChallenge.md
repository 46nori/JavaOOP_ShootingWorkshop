# 応用編: 物理演算シミュレーション (Advanced Challenge)

これまでのステップで学んだオブジェクト指向の知識を活かして、より高度なプログラムに挑戦してみましょう。
今回は、敵キャラクター同士がぶつかって跳ね返る「物理シミュレーション」を作成します。

## 🎯 目標と要件
以下の3つの要件を満たすプログラムを作成します。

### 1. リファクタリングと機能拡張
- Step 8で学んだ「定数」や「カプセル化」を適用する。
- 敵のサイズ（半径）をランダムに変更できるようにする。
- 質量（重さ）の概念を取り入れる（大きい敵ほど重く、ぶつかった時に相手を吹き飛ばす）。

### 2. アルゴリズム変更1：壁での反射
- 画面の端に行ったら、反対側から出てくるのではなく、**壁に当たって跳ね返る**ようにする。
- 入射角と反射角が等しくなるように速度を変化させる。

### 3. アルゴリズム変更2：敵同士の衝突と反発
- 敵同士がぶつかったら、物理法則（作用・反作用）に従って反発するようにする。
- 衝突判定は、中心座標だけでなく**半径**を考慮して行う。
- 衝突後の速度は、お互いの**質量**と**衝突角度**によって計算する。

---

## 📐 アルゴリズム解説

### 1. 壁での反射
壁に当たるということは、座標が画面の端を超えたということです。
反射させるには、**「壁に垂直な方向の速度を反転させる」**だけでOKです。

- **左右の壁**: X方向の速度 (`vx`) を `vx = -vx` にする。
- **上下の壁**: Y方向の速度 (`vy`) を `vy = -vy` にする。

### 2. 敵同士の衝突判定
2つの円が衝突しているかどうかは、**「中心間の距離」**と**「半径の和」**を比べることで分かります。

- 距離 < (半径A + 半径B) ならば、衝突している！

距離 $d$ は、三平方の定理（ピタゴラスの定理）で求められます。
$$ d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2} $$

### 3. 衝突後の速度計算（物理演算）
ここが一番の難所です。2つの物体が斜めに衝突した場合、速度はどのように変化するでしょうか？
これを計算するには、速度を**「衝突面に対して垂直な成分（法線成分）」**と**「平行な成分（接線成分）」**に分解して考えます。

1.  **法線ベクトル**（衝突軸）を求める。
2.  お互いの速度を、この法線方向と接線方向に分解する。
3.  **運動量保存則**と**反発係数**の式を使って、法線方向の新しい速度を計算する。
    - 重い物体と軽い物体がぶつかると、軽いほうが大きく弾き飛ばされます。
4.  新しい速度ベクトルを合成する。

プログラムでは `Enemy.java` の `collideWith` メソッドにこの計算式が実装されています。
少し難しい数学ですが、コードを読んで「物理法則をプログラムでどう表現するか」を感じ取ってください。

## 💻 実装のポイント

### ベクトルによる管理
これまでは「角度(`angle`)」と「速さ(`speed`)」で動きを管理していましたが、物理演算を行う場合は**「X方向の速度(`vx`)」と「Y方向の速度(`vy`)」**（ベクトル成分）で管理する方が計算が簡単になります。

### 二重ループによる総当たり判定
`GameMain.java` では、全ての敵同士の組み合わせをチェックするために、二重ループを使っています。

```java
for (int i = 0; i < enemies.length; i++) {
    for (int j = i + 1; j < enemies.length; j++) {
        // 自分(i)と、自分より後ろにいる敵(j)との衝突を判定
        enemies[i].collideWith(enemies[j]);
    }
}
```
`j` を `i + 1` から始めることで、「AとB」「BとA」のような重複チェックを防いでいます。

## 実行方法
`src/advanced_challenge/GameMain.java` を実行してください。
大小様々なボールが画面内を飛び回り、ぶつかり合って弾ける様子が観察できるはずです。
