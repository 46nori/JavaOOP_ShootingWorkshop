# Step 6: ポリモーフィズム (Polymorphism)

**ポリモーフィズム (多態性)** とは、「同じ命令を出しても、相手によって違う動きをする」ことです。

## 🎯 何を実現したいのか？

前回のステップで、`StraightEnemy` と `WavyEnemy` という2種類の敵を作りました。
もしポリモーフィズムを使わずに、これらを同時に画面に出そうとすると、メインのプログラムはどうなるでしょうか？

### ポリモーフィズムがない場合（面倒！）

「直進する敵」と「波打つ敵」を別々の配列で管理しなければなりません。

```java
StraightEnemy[] straightEnemies = ...;
WavyEnemy[] wavyEnemies = ...;

// 動かすときも別々
for (StraightEnemy e : straightEnemies) e.move();
for (WavyEnemy e : wavyEnemies) e.move();
```

敵の種類が10種類に増えたら、配列もループも10個に増えてしまいます。これは大変です。

### ポリモーフィズムがある場合（スマート！）

「直進する敵」も「波打つ敵」も、**「敵 (Enemy)」としてまとめて扱いたい** です。
そうすれば、敵の種類がいくら増えても、メインのプログラムは変更しなくて済みます。

これを実現するのがポリモーフィズムです。

## 🔑 ポリモーフィズムの仕組み

ポリモーフィズムを理解するための2つの重要なルールがあります。

### 1. 親クラスの変数に、子クラスのインスタンスを代入できる

「直進する敵」も「波打つ敵」も、元をたどれば「敵」の一種です。
Javaでは、**「親クラスの変数（箱）」に「子クラスのインスタンス（中身）」を入れることができます**。

```java
// Enemy型の変数 e を用意
Enemy e;

// 中身は StraightEnemy でもOK！
e = new StraightEnemy(...);

// 中身は WavyEnemy でもOK！
e = new WavyEnemy(...);
```

これを応用すると、異なる種類の敵をひとつの配列でまとめて管理できるようになります。

```java
// Enemy型の配列（敵を入れる箱）を20個用意
Enemy[] enemies = new Enemy[20];

// 0番目の箱には直進する敵を入れる
enemies[0] = new StraightEnemy(...);

// 1番目の箱には波打つ敵を入れる
enemies[1] = new WavyEnemy(...);
```

### 2. 中身の正体に合わせて、メソッドが切り替わる

ここが一番不思議で面白いところです。
変数 `e` の型は `Enemy` ですが、`e.move()` を呼び出したとき、**実際に動くのは「中身のインスタンス」の `move` メソッド** です。

- 中身が `StraightEnemy` なら → `StraightEnemy` の `move` が動く
- 中身が `WavyEnemy` なら → `WavyEnemy` の `move` が動く

これを **動的結合 (Dynamic Binding)** と呼びます。
「箱のラベル」ではなく「中身の正体」を見て、適切なメソッドが自動的に選ばれるのです。

## 実践：まとめて動かす

この仕組みのおかげで、メインループのコードは驚くほどシンプルになります。

```java
// 全員を動かすループ
for (Enemy e : enemies) {
    // eの中身が何であれ、「動け！」と命令するだけ
    e.move(); 
}
```

もしポリモーフィズムがなかったら、こんな風に書かなければなりません（大変！）：

```java
// 悪い例（ポリモーフィズムを使わない場合）
if (e instanceof StraightEnemy) {
    // 直進する敵として扱う処理...
} else if (e instanceof WavyEnemy) {
    // 波打つ敵として扱う処理...
}
```

ポリモーフィズムを使うと、将来「新しい種類の敵」を追加しても、このループのコードは一切変更しなくて済みます。これがオブジェクト指向の最大のメリットの一つです。

## 実行方法

Eclipse上で `src/step06_polymorphism/GameMain.java` を右クリックし、**[Run As]** > **[Java Application]** を選択します。
たくさんの敵が、それぞれの動き方で画面を飛び回っていれば成功です！

次は [Step 7: カプセル化 (Encapsulation)](07_Encapsulation.md) です。
